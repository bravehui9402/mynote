## HashSet

> 快速描述

- 底层数据结构是哈希表
- 封装了HashMap。就是用HashMap的key位来存储值.
- 不能保证元素的排列顺序，顺序可能与添加顺序不同，顺序也有可能发生变化 。
- 不是同步的，线程不安全
- 集合元素值可以是 null

### 元素比较

​		当向 HashSet 集合中存入一个元素时， HashSet 会调用该对象的 hashCode()方法来得到该对象的hashCode 值，然后根据该 hashCode 值决定该对象在 HashSet 中的存储位置。如果有两个元素通过 equals()方法比较返回 true，但它们的 hashCode()方法返回值不相等， HashSet 将会把它们存储在不同的位置， 依然可以添加成功。HashSet 集合判断两个元素相等的标准是两个对象通过 equals()方法比较相等，并且两个对象的 hashCode()方法返回值也相等。

​		当把一个对象放入 HashSet 中时 ，如果需要重写该对象对应类的 equalsO方法 ，则也应该重写其 hashCode()方法 。 规则是 :如果两个对象通过 equals()方法比较返回 true ， 这两个对象的 hashCode 值也应该相同 。

​		散列表用链表数组实现。每个列表被称为桶（ bucket) ，要想査找表中对象的位置， 就要先计算它的散列码， 然后与桶的总数取余， 所得到的结果就是保存这个元素的桶的索引。
![](https://gitee.com/bravehui/PicGoPictureBed/raw/master/img/markmap/20210510195746.png)

例如， 如果某个对象的散列码为 76268, 并且有 128 个桶， 对象应该保存在第 108 号桶中（76268除以 128余 108 )。或许会很幸运， 在这个桶中没有 其他元素，此时将元素直接插人到桶中就可以了。

有时候会遇到桶被占满的情况， 这也是不可避免的。这种现象被称为散列冲突（ hash collision) 。 这时， 需要用新对象与桶中的所有对象进行比较，査看这个对象是否已经存在。如果散列码是合理且随机分布的， 桶的数目也足够大， 需要比较的次数就会很少。

## LinkedHashSet
没啥说的，相对HashSet的无序来说，LinkedHashSet有序，和存入顺序一致。

## TreeSet

> 快速描述

- 非线程安全
- 不可重复
- 可为null
- 可排序
- TreeSet 可以保存对象元素的唯一性（并不是一定保证唯一性，需要根据重写的compaaTo方法来确定）
- 无序，存入顺序和取出不一致
- TreeSet是基于TreeMap实现的。TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。这取决于使用的构造方法。



