> Java虚拟机将描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程称为虚拟机的类加载机制。

## 类加载时机

一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期会经历`加载`、`验证`、`准备`、`解析`、`初始化`、`使用`、`卸载`七个阶段。其中`验证`、`准备`、`解析`统称为`连接`

![](https://gitee.com/bravehui/PicGoPictureBed/raw/master/img/markmap/20210511191552.png)

`加载`、`验证`、`准备`、`初始化`、`卸载`这五个阶段的顺序确定，类型的加载必须按照该顺序按部就班开始。而解析阶段不一定：在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（动态绑定）。

### 加载

在加载阶段，Java虚拟机需要完成三个步骤：

1. 通过类的全限定名获取定义此类的二进制字节流
   - 从zip中读取（jar、ear、war）
   - 从网络中获取（webapplet）
   - 运行时计算生成。动态代理技术
   - 其他文件生成。JSP
2. 将字节流所代表的的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

加载阶段既可以使用Java虚拟机内置的引导类加载器完成，也可以用用户自定义的类加载器完成，开发人员通过定义自己的类加载器控制字节流的获取方式（重写类加载器的findClass()和loadClass()方法），实现根据自己的需要来赋予应用程序获取运行代码的动态性。

### 验证

验证是连接阶段的第一步，确保Class文件的字节流中包含的信息符合《Java虚拟机》的全部约束要求，保证这些信息被当做代码运行后不会危害虚拟机自身的安全。验证阶段大致会完成以下四个阶段的检验动作：

1. 文件格式验证
   验证字节流是否符合Class文件格式的规范。
2. 元数据验证
   对字节码描述信息进行语义分析，以保证其描述信息符合《Java语言规范》要求：
   - 该类是否有父类（除了Object类，所有类都应当有父类）
   - 该类父类是否继承了不允许被继承的类（被final修饰的类）
   - ...
3. 字节码验证
4. 符号引用验证
   最后阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作对类自身以外的各类信息（常量池中的各种符号引用）进行匹配性校验。

### 准备

准备阶段是正式为类中定义的变量（静态变量，被syayoc修饰的变量）分配内存并设置初始值的阶段。从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但方法区本身是一个逻辑上的区域。在JDK7之前，HotSpot使用永久代来实现方法区时，完全符合这个逻辑概念；在JDK8之后，类变量会随着Class对象一起存放在Java堆中，这时候“类变量在方法区”完全是一种对逻辑概念的表述了。

在准备阶段，进行内存分配的仅包括类变量，不包括实例变量，实例变量将会在对象实例化的时候随对象分配在Java堆中。假设：

```java
public static int value = 123;
```

value在准备阶段初始值为0而不是123。此时尚未执行任何Java方法，把value赋值为123的putstatic指令是程序编译后，存放于类构造器<clinit>（）方法之中，所以value的赋值123的操作要到类的初始化阶段才会执行。

![](https://gitee.com/bravehui/PicGoPictureBed/raw/master/img/markmap/20210511200830.png)

```java
public static final int value = 123;
```

被final修饰的类变量在准备阶段就会赋值。

### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，

- 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存中的内容。
- 直接引用：直接引用是可以直接指向目标的指针、相对偏移量或者是一个能够间接定位到目标的句柄。直接引用和虚拟机实现的内存布局直接相关，引用的目标必定已经在虚拟机内存中存在。

《Java虚拟机规范》中并未规定解析阶段发生的具体时间，虚拟机的实现可根据需要自行判断，到底是在类加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前采取解析。

### 初始化

类的初始化是类加载过程的最后一个步骤。在之前的动作中，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作完全由Java虚拟机来主导控制。知道初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交应用程序。

在准备阶段，类变量已被赋值过一次系统要求的初试零值，在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。

## 类加载器

类加载器只用于实现类的加载动作。

对于任意一个类，都必须由加载他的类加载器和该类本身一起共同确定其在虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。通俗讲：比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类必定不相等。

![](https://gitee.com/bravehui/PicGoPictureBed/raw/master/img/markmap/20210511202544.png)

- 启动类加载器

  启动类加载器主要负责加载存放在<JAVA_HOME>\lib目录，或被-Xbootclasspath参数所指定路径存放而且能够被Java虚拟机所识别的类库（rt.jar、tools.jar，名字不符合的类库即使放在lib目录也不会被加载）加载到虚拟机内存中。

- 扩展类加载器

  扩展类加载器负责加载<JAVA_HOME>\lib\ext目录中或被java.ext.dirs系统变量所指定的路径中所有的类库。

  扩展类加载器是Java系统类库的扩展机制，JDK开发团队允许用户将具有通用性的类库放置在ext目录里以扩展JavaSE的功能。扩展类加载器是由Java代码实现的，可以直接在程序中使用扩展类加载器来加载Class文件。

- 应用程序类加载器

  应用程序类加载器也称为系统类加载器，负责加载用户类路径（classpath）上所有的类库。开发者可以直接在代码中使用这个类加载器

- 自定义类加载器

  JDK9之前Java应用都是由这三种类加载器互相配合来完成加载，如果用户认为有必要，可以通过加入自定义类加载器进行扩展。如增加除了磁盘位置之外的Class文件来源，或者通过类加载器实现类的隔离、重载等功能。

### 双亲委派模型

各种类加载器之间的层次关系被称为类加载器的“双亲委派模型”。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。

**双亲委派模型的工作过程是**：如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把请求委派给父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求，子加载器才会尝试自己去完成加载。

> 使用双亲委派模型来组积类加载器之间的关系，显而易见的好处是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系、例如类java.lang.Object，它存放在rt.jar中，无论那个类加载器加载这个类，最终都是委派给处于模型顶端的启动类加载器加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。反之如果没有双亲委派模型，用户自己编写了一个java.lang.Object类，并放在类路径下，系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。