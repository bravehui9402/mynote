自 Sun 发布 Java 语言以来，开始使用 GC 技术来进行内存自动管理，避免了手动管理带来的悬挂指针（Dangling Pointer）问题，很大程度上提升了开发效率，从此 GC 技术也一举成名。GC 有着非常悠久的历史，1960 年有着“Lisp 之父”和“人工智能之父”之称的 John McCarthy 就在论文中发布了 GC 算法，60 年以来， GC 技术的发展也突飞猛进，但不管是多么前沿的收集器也都是基于三种基本算法的组合或应用，也就是说 GC 要解决的根本问题这么多年一直都没有变过。



## 回收算法

### 引用计数法

在对象中添加引用计数器，每当被引用时。计数器值加一；引用失效时，计数器值减一；任何时刻计数器为零的对象就是不可能再被使用的。

主流虚拟机没有使用引用计数法，看似简单但有很多额外情况要考虑。譬如很难解决对象间循环引用的问题。

```java
/*** testGC()方法执行后，objA和objB会不会被GC呢？ **/ 
public class ReferenceCountingGC { 
    public Object instance = null; 
    private static final int _1MB = 1024 * 1024; 
    /*** 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过 */ 
    private byte[] bigSize = new byte[2 * _1MB]; 
    public static void testGC() { 
        ReferenceCountingGC objA = new ReferenceCountingGC(); //A引用+1
        ReferenceCountingGC objB = new ReferenceCountingGC(); //B引用+1
        objA.instance = objB; //B引用+1
        objB.instance = objA; //A引用+1
        objA = null; //A引用-1
        objB = null; //B引用-1
        System.gc();  //无法被回收
    } 
}
```

虽然循环引用的问题可通过 Recycler 算法解决，但是在多线程环境下，引用计数变更也要进行昂贵的同步操作，性能较低，早期的编程语言会采用此算法。

### 可达性分析算法

主流分析算法。通过“GC Roots”根对象作为起始节点，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”。如果某个对象到GCRoots间没有任何引用链相连接，用图论的话来说就是从GCRoots到该对象不可达，则证明此对象是不可能再被使用的。

虽然object5、6、7互相关联，但是对GCRoots是不可达的，因此被判定为可回收的对象

![](https://gitee.com/bravehui/PicGoPictureBed/raw/master/img/markmap/20210511150827.png)

> 可作为GCRoots对象包括以下几种：
>
> - 在栈中引用的对象（栈帧中的本地变量表），比如各线程调用方法堆栈中使用到的参数、局部变量、临时变量等。
> - 在方法区中类静态属性所引用的对象，比如类的引用类型静态变量。
> - 在方法区中常量引用的对象，比如字符串常量池中的引用。
> - 在本地方发展中JNI（Native方法）引用的对象
> - 虚拟机内部引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointException、OutOfMemoryError）等，还有系统类加载器。
> - 所有被同步锁（synchronized关键字）持有的对象
> - 反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

### 引用

在JDK1.2之前，引用的定义：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。

在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用和虚引用，引用强度依次逐渐减弱。

- **强引用**

  是指在代码中普遍存在的引用赋值，类似“Object obj = new Object()”。在任何情况下，只要强引用关系还存在，垃圾回收器就永远不会回收掉被引用的对象。

- **软引用**

  软引用用来描述还有用但非必须的对象。被软引用关联着的对象，在系统将要发生内存溢出的异常前，会把这些对象列进回收范围进行二次回收，如果这次回收还没有足够内存，才会抛出内存溢出异常。`SoftReference类来实现软引用。`

- **弱引用**

  弱引用用来描述非必须的对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾回收器开始工作，无论当前内存是否足够，都会回收掉弱引用关联的对象。`WeakReference类实现弱引用。`

- **虚引用**

  虚引用也被称为“幽灵引用”和"幻影引用"，是最弱的一种引用关系。对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为对象设置虚引用的目的是为了能在这个对象被垃圾回收时收到一个系统通知。`PhantonReference类实现虚引用。`

## 垃圾收集算法

## 标记-清除算法

![](https://gitee.com/bravehui/PicGoPictureBed/raw/master/img/markmap/20210511173054.png)

​		算法分为`“标记”`和`“清除”`两个阶段：首先标记出所有需要被回收的对象，标记完成后，统一回收掉所有被标记的对象。也可以反过来，标记存活的对象，回收所有未被标记的对象。

​		标记-清除算法是最基础的收集算法，后续的收集算法大多以标记-清除算法为基础，对其缺点进行改进而得到。

​		标记-清除算法主要缺点有两个：1、执行效率不稳定，如果堆中有大量对象，其中大部分需要回收，必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率随对象数量增长而降低。2、内存空间的碎片化问题，标记、清除后产生大量不连续的内存碎片，空间碎片太多可能会导致后续分配大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集操作。

### 标记-复制算法

![](https://gitee.com/bravehui/PicGoPictureBed/raw/master/img/markmap/20210511173743.png)

标记-复制算法简称复制算法，为了解决标记-清除算法面对大量可回收对象时效率低的问题。标记-复制算法将可用内存`按容量划分为大小相等的两块`每次只是用其中一块。当这一块用完了，就将还存活的对象复制到另一块上，然后将已使用过的内存空间一次性清理。

如果内存中多数对象都是存活的，标记复制算法将产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑空间碎片的复杂情况，只需要移动对顶指针，按顺序分配即可。

这样实现简单，运行高效，但是代价是将可用内存缩小为原来的一般，空间浪费。

虚拟机大多优先采用这种收集算法回收新生代，

### 标记-清理算法

![](https://gitee.com/bravehui/PicGoPictureBed/raw/master/img/markmap/20210511184406.png)

标记-复制算法在对象存活率较高时就要进行较多的赋值操作，效率降低。针对老年代对象的存亡特征，标记-整理算法应运而生，其中标记过程与标记-清除算法一样，但后续步骤直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后清理边界以外的内存。

标记清除和标记整理算法的本质差异在于前者是非移动式的回收算法，后者是移动式的。如果移动存活对象，尤其对于老年代每次回收都有大量对象存活区域，移动存活对象并更新所有引用这些对象的地方将是一种极为负重的操作，而且对象移动操作必须全程暂停用户应用程序才能进行。相反，如果不移动对象，弥散于堆中的存活对象导致空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决；内存访问是用户程序最频繁的操作，在这个环节增加额外的负担，势必会直接影响应用程序的吞吐量。

![](https://gitee.com/bravehui/PicGoPictureBed/raw/master/img/markmap/20210511205249.png)

### 分代收集理论

当前虚拟机多数遵循`分代收集`的理论进行设计，建立在两个假说之上：

- 弱分代假说：绝大数对象都是朝生夕灭
- 强分代假说：熬过越多次垃圾收集过程的对象越难以消亡。

收集器应将Java堆划分出不同区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同区域进行存储。如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，将它们集中放在一起，每次回收只关注如何保留少量存活对象而不是去标记那些大量将要被回收的对象，就能以较低价会受到大量的空间；如果剩下的都是难以消亡的对象，将它们集中放在一起，使用较低的频率回收这个区域，同时兼顾了垃圾回收的时间开销和内存的空间有效利用。

在堆中划分出不同区域，垃圾收集器每次只回收其中某一个或某些部分区域。因而有了`MinorGC` `MajorGC` `FullGC`回收类型的划分。

> - 部分收集（PartialGC）：目标不是完整收集整个堆的垃圾收集
>   - 新生代收集（MinorGC/YoungGC）:目标只是新生代的垃圾收集
>   - 老年代收集（MajorGC/OldGC）：目标只是老年代的垃圾收集。目前只有CMS收集器有单独收集老年代的行为。
>   - 混合收集（MixedGC）：目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器有这种行为
> - 整堆收集（FullGC）：收集整个Java堆和方法区的垃圾收集